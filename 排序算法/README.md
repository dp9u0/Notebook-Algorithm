# 排序算法

一个排序算法是一种能将一串数据依照特定排序方式进行排列的一种算法.最常用到的排序方式是数值顺序以及字典顺序.有效的排序算法在一些算法中是重要的,如此这些算法才能得到正确解答.排序算法也用在处理文字数据以及产生人类可读的输出结果.基本上,排序算法的输出必须遵守下列两个原则:

* 输出结果为递增序列(递增是针对所需的排序顺序而言)
* 输出结果是原输入的一种排列,或是重组

常见的排序和复杂度如下:

| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 排序方式 | 稳定性 |
| -------- | -------------- | -------------- | ---------- | -------- | ------ |
| 冒泡排序 | O(n^2)         | -              | O(1)       | 交换     | 稳定   |
| 选择排序 | O(n^2)         | -              | O(1)       | 选择     | 不稳定 |
| 插入排序 | O(n^2)         | -              | O(1)       | 插入     | 稳定   |
| 希尔排序 | O(nlog(n))     | O(n^2)         | O(1)       | 插入     | 不稳定 |
| 归并排序 | O(nlog(n))     | -              | O(n)       | 合并     | 稳定   |
| 快速排序 | O(nlog(n))     | O(n^2)         | O(log(n))  | 交换     | 不稳定 |
| 堆排序   | O(nlog(n))     | -              | O(1)       | 选择     | 不稳定 |
| 计数排序 | O(n+k)         | -              | O(k)       |          | 稳定   |
| 基数排序 | O(n*k)         | -              | O(n+k)     |          | 稳定   |
| 桶排序   | O(n+k)         | -              | O(k)       |          | 稳定   |

* 均按从小到大排列
* k 代表数据个数
* n 代表数据规模

## 冒泡排序

冒泡排序算法的运作如下:

1. 比较相邻的元素.如果第一个比第二个大,就交换他们两个.
2. 对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对.这步做完后,最后的元素会是最大的数.
3. 针对所有的元素重复以上的步骤,除了最后一个.
4. 持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较.

```Pseudocode
bubble_sort (array) {
  for(i from 1 to length(array) - 1){
    for(j from 0 to length(array)- 1 - i){
      if (array[j] > array[j+1])
        swap(array[j], array[j+1])
    }
  }
}
```

![冒泡排序](img/bubbleSort.gif)

## 快速排序

![快速排序](img/quickSort.gif)

## 插入排序

![插入排序](img/insertionSort.gif)

## 希尔排序

![希尔排序](img/shellSort.gif)

## 选择排序

![选择排序](img/selectionSort.gif)

## 堆排序

## 归并排序

![归并排序](img/mergeSort.gif)

## 计数排序

![计数排序](img/countingSort.gif)

## 基数排序

## 桶排序
