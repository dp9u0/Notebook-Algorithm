# 排序算法

一个排序算法是一种能将一串数据依照特定排序方式进行排列的一种算法.最常用到的排序方式是数值顺序以及字典顺序.有效的排序算法在一些算法中是重要的,如此这些算法才能得到正确解答.排序算法也用在处理文字数据以及产生人类可读的输出结果.基本上,排序算法的输出必须遵守下列两个原则:

* 输出结果为递增序列(递增是针对所需的排序顺序而言)
* 输出结果是原输入的一种排列,或是重组

常见的排序和复杂度如下:

| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 排序方式 | 稳定性 |
| -------- | -------------- | -------------- | ---------- | -------- | ------ |
| 冒泡排序 | O(n^2)         | -              | O(1)       | 交换     | 稳定   |
| 选择排序 | O(n^2)         | -              | O(1)       | 选择     | 不稳定 |
| 插入排序 | O(n^2)         | -              | O(1)       | 插入     | 稳定   |
| 希尔排序 | O(nlog(n))     | O(n^2)         | O(1)       | 插入     | 不稳定 |
| 归并排序 | O(nlog(n))     | -              | O(n)       | 合并     | 稳定   |
| 快速排序 | O(nlog(n))     | O(n^2)         | O(log(n))  | 交换     | 不稳定 |
| 堆排序   | O(nlog(n))     | -              | O(1)       | 选择     | 不稳定 |
| 计数排序 | O(n+k)         | -              | O(k)       |          | 稳定   |
| 基数排序 | O(n*k)         | -              | O(n+k)     |          | 稳定   |
| 桶排序   | O(n+k)         | -              | O(k)       |          | 稳定   |

* 均按从小到大排列
* k 代表数据个数
* n 代表数据规模

## 冒泡排序

这个算法的名字由来是因为越小的元素会经由交换慢慢浮到数列的顶端.

步骤为:

1. 比较相邻的元素.如果第一个比第二个大,就交换他们两个.
2. 对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对.这步做完后,最后的元素会是最大的数.
3. 针对所有的元素重复以上的步骤,除了最后一个.
4. 持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较.

```Pseudocode
bubbleSort(A)
  for i := 1 to length(A) - 1 do
    for j := 0 to length(A)- 1 - i do
      if (A[j] > A[j+1]) then
        swap(A[j],A[j+1])
```

![冒泡排序](img/bubbleSort.gif)

## 快速排序

快速排序使用分治法(*Divide and conquer*)策略来把一个序列(list)分为两个子序列(sub-lists).

步骤为:

1. 从数列中挑出一个元素,称为基准(*pivot*),
2. 重新排序数列,所有比基准值小的元素摆放在基准前面,所有比基准值大的元素摆在基准后面(相同的数可以到任何一边).在这个分割结束之后,该基准就处于数列的中间位置.这个称为分割(partition)操作.
3. 递归(recursively)把小于基准值元素的子数列和大于基准值元素的子数列排序.

```Pseudocode
quickSort(A, lo, hi)
    if lo < hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p - 1)
        quicksort(A, p + 1, hi)

partition(A, lo, hi)
    pivot := A[hi]
    i := lo
    for j := lo to hi - 1 do
        if A[j] < pivot then
            swap(A[i],A[j])
            i := i + 1
    swap(A[i],A[hi])
    return i
```

![快速排序](img/quickSort.gif)

## 插入排序

插入排序是一种简单直观的排序算法.它的工作原理是通过构建有序序列,对于未排序数据,在已排序序列中从后向前扫描,找到相应位置并插入.插入排序在实现上,通常采用in-place排序(即只需用到 O(1) 的额外空间的排序),因而在从后向前扫描过程中,需要反复把已排序元素逐步向后挪位,为最新元素提供插入空间.

步骤为:

1. 从第一个元素开始,该元素可以认为已经被排序
2. 取出下一个元素,在已经排序的元素序列中从后向前扫描
3. 如果该元素(已排序)大于新元素,将该元素移到下一位置
4. 重复步骤3,直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

```Pseudocode
insertionSort(A)
  for i := 1 to length(A) - 1 do
    j := i - 1
    while j >= 0 and A[j] > A[i] do
      A[j+1] := A[j]
      j := j - 1
    A[j+1] := A[i]
```

![插入排序](img/insertionSort.gif)

## 希尔排序

![希尔排序](img/shellSort.gif)

## 选择排序

选择排序是一种简单直观的排序算法.它的工作原理如下.首先在未排序序列中找到最小元素,存放到排序序列的起始位置,然后,再从剩余未排序元素中继续寻找最小元素,然后放到已排序序列的末尾.以此类推,直到所有元素均排序完毕.

```Pseudocode
insertionSort(A)
  for i := 0 to length(A) - 1 do
    min := i;
    for j := i + 1 to length(A)- 1 - i do
      if (A[min] > A[j]) then
        min := j
    swap(A[j],A[j+1])
```

![选择排序](img/selectionSort.gif)

## 堆排序

## 归并排序

![归并排序](img/mergeSort.gif)

## 计数排序

![计数排序](img/countingSort.gif)

## 基数排序

## 桶排序
